use gba::video::{
    Tile4,
    obj::{
        ObjShape, 
        ObjAttr, 
        ObjAttr0, 
        ObjAttr1, 
        ObjAttr2, 
        ObjDisplayStyle
    }
};

use voladdress::Safe;

use crate::system::gba::{ClaimedVolRegion, GBA};

pub struct Sprite {
    tiles: &'static [Tile4],
    palette_bank: u8,
    shape: ObjShape,
    size: u16,
}

pub struct LoadedSprite<'a> {
    sprite: &'a Sprite,
    memory: ClaimedVolRegion<'a, Tile4, Safe, Safe, 1024>,
}

impl Sprite {
    pub fn load<'a>(&'a self, gba: &'a GBA) -> LoadedSprite<'a> {
        let mut memory = gba.obj_tile_memory.request_memory(self.tiles.len());
        let mem_region = memory.as_vol_region();        

        for i in 0..self.tiles.len() {    
            mem_region.index(i).write(self.tiles[i]);
        }

        LoadedSprite {
            sprite: &self,
            memory,
        }
    }
}

impl<'a> LoadedSprite<'a> {
    pub fn sprite(&'a self) -> &'a Sprite {
        self.sprite
    }

    pub fn create_obj_attr_entry(&self) -> ObjAttr {
        let mut oa = ObjAttr::new();
        oa.0 = ObjAttr0::new()
            .with_bpp8(false)
            .with_shape(self.sprite.shape)
            .with_style(ObjDisplayStyle::Normal);

        oa.1 = ObjAttr1::new().with_size(self.sprite.size);

        oa.2 = ObjAttr2::new()
            .with_tile_id(self.memory.get_start().try_into().unwrap())
            .with_palbank(self.sprite.palette_bank.into());

        oa
    }
}

// Insert all of the code generated by the build sript.
// This will contain static definitions for all of our aseprite files.
include!(concat!(env!("OUT_DIR"), "/sprite_data.rs"));
