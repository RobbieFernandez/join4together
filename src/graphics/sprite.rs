use gba::video::{
    obj::{ObjAttr, ObjAttr0, ObjAttr1, ObjAttr2, ObjDisplayStyle, ObjShape},
    Tile4,
};

use voladdress::Safe;

use crate::system::gba::{ClaimedVolAddress, ClaimedVolRegion, GBA};

pub struct Sprite {
    tiles: &'static [Tile4],
    palette_bank: u8,
    shape: ObjShape,
    size: u16,
    width: usize,
    height: usize,
}

pub struct LoadedSprite<'a> {
    sprite: &'a Sprite,
    memory: ClaimedVolRegion<'a, Tile4, Safe, Safe, 1024>,
}

pub struct Animation<const C: usize> {
    sprites: [&'static Sprite; C],
    /// How many screen refreshes each frame in the animation lasts for. 1 == 60fps, 2 == 30fps etc
    tick_rate: u8,
}

pub struct LoadedAnimation<'a, const C: usize> {
    animation: &'a Animation<C>,
    loaded_sprites: [LoadedSprite<'a>; C],
}

pub struct LoadedObjectEntry<'a> {
    slot: ClaimedVolAddress<'a, ObjAttr, Safe, Safe, 128>,
    obj_attr: ObjAttr,
}

impl Sprite {
    pub fn load<'a>(&'a self, gba: &'a GBA) -> LoadedSprite<'a> {
        let mut memory = gba
            .obj_tile_memory
            .request_memory(self.tiles.len())
            .expect("Out of VRAM.");

        let mem_region = memory.as_vol_region();

        for i in 0..self.tiles.len() {
            mem_region.index(i).write(self.tiles[i]);
        }

        LoadedSprite {
            sprite: self,
            memory,
        }
    }

    pub fn height(&self) -> usize {
        self.height
    }

    pub fn width(&self) -> usize {
        self.width
    }
}

impl<'a> LoadedSprite<'a> {
    pub fn sprite(&'a self) -> &'a Sprite {
        self.sprite
    }

    pub fn create_obj_attr_entry(&'a self, gba: &'a GBA) -> LoadedObjectEntry<'a> {
        let mut oa = ObjAttr::new();
        oa.0 = ObjAttr0::new()
            .with_bpp8(false)
            .with_shape(self.sprite.shape)
            .with_style(ObjDisplayStyle::Normal);

        oa.1 = ObjAttr1::new().with_size(self.sprite.size);

        oa.2 = ObjAttr2::new()
            .with_tile_id(self.memory.get_start().try_into().unwrap())
            .with_palbank(self.sprite.palette_bank.into());

        let slot = gba.obj_attr_memory.request_slot().expect("Out of OBJRAM");

        LoadedObjectEntry { slot, obj_attr: oa }
    }
}

impl<'a> LoadedObjectEntry<'a> {
    pub fn commit_to_memory(&mut self) {
        self.slot.as_vol_address().write(self.obj_attr);
    }

    pub fn get_obj_attr_data(&mut self) -> &mut ObjAttr {
        &mut self.obj_attr
    }
}

impl<const C: usize> Animation<C> {
    pub fn load<'a>(&'a self, gba: &'a GBA) -> LoadedAnimation<'a, C> {
        let loaded_sprites = core::array::from_fn(|i| self.sprites[i].load(gba));
        LoadedAnimation {
            animation: self,
            loaded_sprites,
        }
    }
}

impl<'a, const C: usize> LoadedAnimation<'a, C> {
    pub fn get_sprite(&'a self, time: u16) -> &'a LoadedSprite {
        // Convert from time to the sprite index by dividing by tick rate.
        let num_frames: u16 = C.try_into().unwrap();
        let tick_rate: u16 = self.animation.tick_rate.into();
        let index: u16 = (time / tick_rate) % num_frames;

        // This will definitely fit into a usize, because the mod guarantees
        // it's <= C, which is a usize.
        let index: usize = index.try_into().unwrap();

        &self.loaded_sprites[index]
    }
}

// Insert all of the code generated by the build sript.
// This will contain static definitions for all of our aseprite files.
include!(concat!(env!("OUT_DIR"), "/sprite_data.rs"));
